# Provides fast drawing routines to load bitmap images on TFT LCD displays.

This repository contains an example sketch and a helper file that was originally modified from the bitmapdraw example included with the AdaFruit HX8357 library. This highly modified sketch loads several bitmap files which have been saved in various .bmp formats.

The sketch and helper have been designed for AdaFruit 3.5" & 2.4" TFT LCD featherwings using either the Feather M4 Express or the Feather M0 Express. 

The repository contains two graphics directories.  One for 480x320 images (requiring the HX8357 interface on the 3.5" display) and the other for 320x240 images (requiring the ILI9341 interface on the 2.4" display).  These directories contain bitmap files, many of which look the same but they are different file sizes due to various types of formatting. 

To run the program without modification you'll need to copy these directories to subdirectories on a SD card connected to the display.  To get the full speed advantage you also need to copy these files to subdirectories on the onboard Flash which is standard on the AdaFruit Express boards.  For the flash copying you'll have to chose one display type or the other since I'm pretty sure you will not be able to fit both at the same time.

How do you copy to the Flash device? First use your host computer to copy to your SD card, then see https://github.com/MrBryonMiller/DOS-for-Adafruit-M4-Express-boards.

You'll need to tell the sketch which display type you are using by either commenting or uncommenting the line that says 

<pre>#define USEILI9341</pre>
Keep the define if you are using the 2.4 inch display.  Comment out the define if you are using the 3.5 inch diaplay.

# Usage Notes
There are three main functions available in the bmpDraw.h file.  Each of these three have two set of calling arguements.  Each needs the name of the File, the x & y coordinates and an optional arguement defining whether the call should be "Loud" or not.  Loud determines whether the function utilizes Serial prints to give file information.

The three main functions are
<pre>bmpDraw
bmpFlashDraw
bmpFlashDrawDMA</pre>

bmpDraw gets the specified file from the SD card.  The other two functions utilize files stored on the Express Flash chip.  It is not considered viable to use DMA to write the display memory when the SD card is used as the file source.  This is because both getting the data and writing the data would be over the same SPI bus.

# Create your own bitmap files
I only use Windows so I can only talk about this from that perspective.  I initially used Paint to create bitmaps but it is pretty limited in any of the less-dense formats.  I use the latest version of Gimp to change 24 bit bitmaps generated by paint to all of the other formats the routines decode.

# Design notes

Using the M4 and the 3.5 inch display, drawing a full screen image took over 2.2 seconds. (this is better than 3.8 seconds with a M0) but I was wondering if it could be done better. I ended up with an approach that can draw the entire screen in 0.3 seconds. Getting into the territory where you could animate by redrawing if you weren't trying to animate the entire screen.

To get to this speed I took two approaches. 1) Trying some simple file compressions and 2) getting the image file off of the Flash memory included on the Feather board.

File compression - Since it seemed that a lot of time was reading the file from the Flash card I felt that compression would make the file smaller thus faster. I wasn't ready to try something like jpeg decompression so I thought I'd see what I could do with BMP files. The baseline is full 24 bit file format. I used gimp on a Windows 10 machine for all my compression work.

Step 1) It is fairly easy to save the file in a 16 bit format. When using 16 bit it uses 565 compression which is the same that the HX8357 uses. So while there is some loss of available colors it is no worse than what you can see even if the file is full 24 bit. The image ends up being about 2/3 the size of the original image.

Step 2) For many, but not all images, you can have a very realistic image by limiting yourself to 256 (or even 16) colors. In gimp you can change the the mode of the image to "indexed". When you save an indexed file as a BMP it will utilize the 8 bit (or 4bit) BMP format. The 8 bit format will reduce the image to about 1/3 the size of the original image.  The 4 bit format even smaller.

Step 3) Still staying with an indexed image, gimp also allows saving with Run Length Encoding (RLE). Again, the image really matters because you can get a decent compression on some images, but not all. The image I used ended up being about 87% the size of the indexed image. Not a big compression but a remarkable time improvement.  (It turn out that a big part of the time improvement was from drawing the image from bottom to top, so this is now the standard technique.)

Utilizing Flash memory - The second branch in speeding things up was to take advantage of the on-board Flash. And since I was using an M4 I could further utilize the QSPI speeds of accessing that flash. Additionally, given that I would get my file data on the QSPI bus I was able to use DMA to SPI write to the display. So for my final approach I read a block of data from the Flash file and got the DMA going to transfer it to the LCD. While the DMA transfer was taking place I could go after the next block of Flash data. Until the entire file was transferred.
